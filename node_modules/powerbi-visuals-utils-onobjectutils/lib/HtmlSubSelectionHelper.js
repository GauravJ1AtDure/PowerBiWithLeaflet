"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlSubSelectionHelper = exports.SubSelectableRestrictingElementAttribute = exports.SubSelectableUIAnchorAttribute = exports.SubSelectableSubSelectedAttribute = exports.SubSelectableDirectEdit = exports.SubSelectableTypeAttribute = exports.SubSelectableAltObjectNameAttribute = exports.SubSelectableObjectNameAttribute = exports.SubSelectableHideOutlineAttribute = exports.SubSelectableDisplayNameAttribute = exports.HtmlSubSelectableSelector = exports.HtmlSubSelectableClass = exports.FormatModeAttribute = exports.DirectEditPlaceholderOutlineClassAndSelector = exports.DirectEditPlaceholderClassAndSelector = void 0;
const d3_selection_1 = require("d3-selection");
const helperFunctions_1 = require("./helperFunctions");
const d3 = { select: d3_selection_1.select, selectAll: d3_selection_1.selectAll };
// Used on the sub-selectable element
const eventSuffix = 'htmlSubSelection';
const subSelectableClassAndSelector = createClassAndSelector('sub-selectable');
const SubSelectionData = 'sub-selection-data';
exports.DirectEditPlaceholderClassAndSelector = createClassAndSelector('direct-edit-placeholder');
exports.DirectEditPlaceholderOutlineClassAndSelector = createClassAndSelector('direct-edit-placeholder-outline');
exports.FormatModeAttribute = 'format-mode';
exports.HtmlSubSelectableClass = subSelectableClassAndSelector.class;
exports.HtmlSubSelectableSelector = subSelectableClassAndSelector.selector;
exports.SubSelectableDisplayNameAttribute = 'data-sub-selection-display-name';
exports.SubSelectableHideOutlineAttribute = 'data-sub-selection-hide-outline';
exports.SubSelectableObjectNameAttribute = 'data-sub-selection-object-name';
// Used for when another object is associated with the sub-selectable element (e.g. Lines/Markers on interactivity lines)
exports.SubSelectableAltObjectNameAttribute = 'data-sub-selection-alt-object-name';
exports.SubSelectableTypeAttribute = 'data-sub-selection-type';
exports.SubSelectableDirectEdit = 'data-sub-selection-direct-edit';
exports.SubSelectableSubSelectedAttribute = 'data-sub-selection-sub-selected';
exports.SubSelectableUIAnchorAttribute = 'data-sub-selection-ui-anchor';
// Used to indicate the element which will restricted the outlines and the type of restriction (clamp or clip)
exports.SubSelectableRestrictingElementAttribute = 'data-sub-selection-restricting-element';
/** Indicates that this helper has attached to this element */
const helperHostAttribute = 'data-helper-host';
const scrollDebounceInterval = 100;
function getEventName(eventName) {
    return `${eventName}.${eventSuffix}`;
}
function helperOwnsElement(host, element) {
    return element.closest(`[${helperHostAttribute}]`) === host;
}
function createClassAndSelector(className) {
    return {
        class: className,
        selector: '.' + className,
    };
}
class HtmlSubSelectionHelper {
    constructor(args) {
        this.hostElement = args.hostElement;
        this.host = d3.select(args.hostElement);
        this.subSelectionService = args.subSelectionService;
        this.subSelectionRegionOutlines = {};
        this.selectionIdCallback = args.selectionIdCallback;
        this.customOutlineCallback = args.customOutlineCallback;
        this.customElementCallback = args.customElementCallback;
        this.subSelectionMetadataCallback = args.subSelectionMetadataCallback;
        this.host.attr(helperHostAttribute, true);
    }
    static createHtmlSubselectionHelper(args) {
        return new HtmlSubSelectionHelper(args);
    }
    setCustomOutlineCallback(customOutlineCallback) {
        this.customOutlineCallback = customOutlineCallback;
    }
    destroy() {
        this.removeEventHandlers();
        this.hideAllOutlines();
    }
    setFormatMode(isFormatMode) {
        if (this.formatMode === isFormatMode) {
            return;
        }
        this.formatMode = isFormatMode;
        if (isFormatMode) {
            this.attachEventHandlers();
        }
        else {
            this.removeEventHandlers();
            this.hideAllOutlines();
        }
    }
    attachEventHandlers() {
        this.host.on(getEventName('pointerover'), (event) => {
            this.onPointerOver(event);
        });
        this.host.on(getEventName('click'), (event) => {
            this.onClick(event);
        });
        this.host.on(getEventName('contextmenu'), (event) => {
            this.onContextMenu(event);
        });
    }
    removeEventHandlers() {
        this.host.on(getEventName('pointerover'), null);
        this.host.on(getEventName('click'), null);
        this.host.on(getEventName('contextmenu'), null);
    }
    onVisualScroll() {
        // if scrolling
        if (!this.scrollDebounce) {
            this.onVisualScrollStart();
            this.scrollDebounce = (0, helperFunctions_1.debounce)(() => this.onVisualScrollEnd(), scrollDebounceInterval);
        }
        this.scrollDebounce();
    }
    // clear subselections and set up state
    onVisualScrollStart() {
        if (this.scrollSubSelections) {
            return;
        }
        this.subSelectionService.subSelect(undefined);
        this.scrollSubSelections = this.subSelections;
    }
    // reapply subselections
    onVisualScrollEnd() {
        if (this.scrollSubSelections && this.scrollSubSelections.length > 0) {
            this.subSelectionService.subSelect(this.scrollSubSelections[0]);
        }
        this.scrollSubSelections = undefined;
        this.scrollDebounce = undefined;
    }
    onPointerOver(event) {
        this.clearHoveredOutline();
        const subSelectionSource = this.getSubSelectionSourceFromEvent(event);
        if (subSelectionSource && subSelectionSource.subSelectionElement) {
            // If visualSubSelection has custom outlines, omit default behavior
            // If custom outline is already active, don't set to hover
            const visualSubSelectionsWithCustomOutlines = this.updateCustomOutlinesFromSubSelections([subSelectionSource.visualSubSelection], 1 /* SubSelectionOutlineVisibility.Hover */);
            if (visualSubSelectionsWithCustomOutlines.length === 0) {
                let elementsToUpdate = this.getSubSelectionElementsFromSubSelectionSource(subSelectionSource);
                // Skip sub-selected elements or elements which should not be outlined
                elementsToUpdate = elementsToUpdate.filter(e => {
                    const selectedElement = d3.select(e);
                    return !selectedElement.attr(exports.SubSelectableSubSelectedAttribute) && selectedElement.attr(exports.SubSelectableHideOutlineAttribute) !== "true";
                });
                this.updateOutlinesFromSubSelectionElements(elementsToUpdate, 1 /* SubSelectionOutlineVisibility.Hover */);
            }
            this.renderOutlines();
            const pointerLeaveEventName = getEventName('pointerleave');
            const targetedElement = d3.select(subSelectionSource.subSelectionElement);
            // Attach a listener for leaving the sub-selected element
            // For entry, we care about hovering over any of the children of sub-selectable elements, so we can listen to all events and filter
            // For exit, we only want to react when you move outside of the sub-selection (so far).
            // That's more difficult with a single top-level handler and not storing state, so going with attaching events for now
            targetedElement.on(pointerLeaveEventName, () => {
                // Skip sub-selected elements
                if (targetedElement.attr(exports.SubSelectableSubSelectedAttribute)) {
                    return;
                }
                this.clearHoveredOutline();
                targetedElement.on(pointerLeaveEventName, null);
            });
        }
    }
    clearHoveredOutline() {
        const regionOutlines = (0, helperFunctions_1.getObjectValues)(this.subSelectionRegionOutlines);
        const hoveredOutline = regionOutlines.find(outline => outline.visibility === 1 /* SubSelectionOutlineVisibility.Hover */);
        if (hoveredOutline) {
            this.subSelectionRegionOutlines[hoveredOutline.id] = Object.assign(Object.assign({}, this.subSelectionRegionOutlines[hoveredOutline.id]), { visibility: 0 /* SubSelectionOutlineVisibility.None */ });
            this.renderOutlines();
        }
    }
    onClick(event) {
        this.subSelectFromEvent(event, false /* showUI */);
    }
    onContextMenu(event) {
        this.subSelectFromEvent(event, true /* showUI */);
    }
    subSelectFromEvent(event, showUI) {
        event.preventDefault();
        const newSubSelectionElements = this.getSubSelectionElementsFromEvent(event);
        // Mark the event as handled so containers don't process this event
        const selectionOrigin = {
            x: event.clientX,
            y: event.clientY,
        };
        if ((0, helperFunctions_1.isArrayEmpty)(newSubSelectionElements)) {
            this.subSelectionService.subSelect({
                customVisualObjects: [],
                selectionOrigin,
                showUI,
                displayName: '',
                subSelectionType: 3 /* SubSelectionStylesType.Shape */
            });
            return;
        }
        const newSubSelection = newSubSelectionElements[0];
        const args = this.getCreateVisualSubSelectionArgs(event, newSubSelection, showUI);
        const subSelection = this.createVisualSubSelectionForSingleObject(args);
        this.scrollSubSelections = undefined;
        this.subSelectionService.subSelect(subSelection);
    }
    getSubSelectionElementsFromEvent(event) {
        const subSelectionSource = this.getSubSelectionSourceFromEvent(event);
        const subSelectionElements = this.getSubSelectionElementsFromSubSelectionSource(subSelectionSource);
        return subSelectionElements;
    }
    getSubSelectionSourceFromEvent(event) {
        const fullPath = event.composedPath();
        if (!fullPath) {
            return undefined;
        }
        // Find the root element in the path, remove everything above it
        const eventHandlerElementIndex = fullPath.indexOf(this.hostElement);
        const path = fullPath.slice(0, eventHandlerElementIndex + 1);
        let subSelectionElement;
        // Use the closest parent to the event
        for (const currentElement of path) {
            const currentSelection = d3.select(currentElement);
            // Only supports one level for now
            if (currentSelection.classed(exports.HtmlSubSelectableClass)) {
                subSelectionElement = currentElement;
                break;
            }
        }
        if (subSelectionElement && helperOwnsElement(this.hostElement, subSelectionElement)) {
            const args = this.getCreateVisualSubSelectionArgs(event, subSelectionElement, false /**showUI */);
            const visualSubSelection = this.createVisualSubSelectionForSingleObject(args);
            return { subSelectionElement, visualSubSelection };
        }
        return undefined;
    }
    getCreateVisualSubSelectionArgs(event, subSelectionElement, showUI) {
        const selectionId = this.selectionIdCallback ? this.selectionIdCallback(subSelectionElement) : undefined;
        const objectName = d3.select(subSelectionElement).attr(exports.SubSelectableObjectNameAttribute);
        const displayName = this.getDisplayNameFromElement(subSelectionElement);
        const subSelectionType = this.getSubSelectionTypeFromElement(subSelectionElement);
        const selectionOrigin = {
            x: event.clientX,
            y: event.clientY,
        };
        const metadata = this.subSelectionMetadataCallback ? this.subSelectionMetadataCallback(subSelectionElement) : null;
        return {
            objectName,
            subSelectionType,
            displayName,
            showUI,
            selectionId,
            selectionOrigin,
            metadata,
        };
    }
    getSubSelectionElementsFromSubSelectionSource(subSelectionSource) {
        if (!subSelectionSource) {
            return [];
        }
        const { visualSubSelection } = subSelectionSource;
        if (this.customElementCallback) {
            const customElements = this.customElementCallback(visualSubSelection);
            if (!(0, helperFunctions_1.isArrayEmpty)(customElements)) {
                return customElements;
            }
        }
        const subSelectables = this.getSubSelectableElements();
        const { objectName, selectionId } = visualSubSelection.customVisualObjects[0];
        let filteredSelectionElements = subSelectables.filter((subSelectable) => subSelectable.getAttribute(exports.SubSelectableObjectNameAttribute) === objectName);
        if (this.selectionIdCallback) {
            const callback = (e) => this.selectionIdCallback(e);
            filteredSelectionElements = filteredSelectionElements.filter((element) => (0, helperFunctions_1.equalsSelectionId)(selectionId, callback(element)));
        }
        return filteredSelectionElements;
    }
    updateElementOutline(element, visibility, suppressRender = false) {
        return this.updateElementOutlines([element], visibility, suppressRender)[0];
    }
    updateElementOutlines(elements, visibility, suppressRender = false) {
        // Group up the elements into their region
        const elementsByOutlineRegionId = (0, helperFunctions_1.groupArrayElements)(elements, element => {
            const subSelectedElement = d3.select(element);
            const regionId = this.getElementRegionOutlineId(subSelectedElement);
            return regionId;
        });
        const regionOutlineIds = Object.keys(elementsByOutlineRegionId);
        for (const regionOutlineId of regionOutlineIds) {
            const subSelectionRegionOutline = this.getSubSelectionRegionOutline(regionOutlineId, elementsByOutlineRegionId[regionOutlineId], visibility);
            this.subSelectionRegionOutlines[regionOutlineId] = subSelectionRegionOutline;
        }
        if (!suppressRender) {
            this.renderOutlines();
        }
        return regionOutlineIds;
    }
    getSubSelectionRegionOutline(id, elements, visibility) {
        const outlines = [];
        let regionClipElement;
        let regionClampElement;
        for (const element of elements) {
            let outline = this.getRectangleSubSelectionOutline(element);
            const currentClampRestriction = this.getRestrictionElement(element, 0 /* SubSelectionOutlineRestrictionType.Clamp */);
            regionClampElement = currentClampRestriction;
            if (regionClampElement) {
                const clampRect = this.applyElementRestriction(regionClampElement, element);
                const newX = Math.max(outline.x, clampRect.left);
                const newY = Math.max(outline.y, clampRect.top);
                outline = Object.assign(Object.assign({}, outline), { x: newX, y: newY, height: Math.min(clampRect.top + clampRect.height - newY, outline.height), width: Math.min(clampRect.left + clampRect.width - newX, outline.width) });
            }
            const currentClipRestriction = this.getRestrictionElement(element, 1 /* SubSelectionOutlineRestrictionType.Clip */);
            regionClipElement = currentClipRestriction;
            if (regionClipElement) {
                const clipRect = this.applyElementRestriction(regionClipElement, element);
                outline = Object.assign(Object.assign({}, outline), { clipPath: {
                        type: 1 /* SubSelectionOutlineType.Rectangle */,
                        x: clipRect.left,
                        y: clipRect.top,
                        height: clipRect.height,
                        width: clipRect.width,
                    } });
            }
            if (outline.height > 0 && outline.width > 0) {
                outlines.push(outline);
            }
        }
        const groupOutline = {
            type: 0 /* SubSelectionOutlineType.Group */,
            outlines,
        };
        return {
            id,
            visibility,
            outline: groupOutline,
        };
    }
    getRestrictionElement(element, type) {
        const restrictionElement = element.closest(`[${exports.SubSelectableRestrictingElementAttribute}="${type}"]`);
        if (restrictionElement && helperOwnsElement(this.hostElement, restrictionElement)) {
            return restrictionElement;
        }
        return undefined;
    }
    applyElementRestriction(restrictingElement, subselectionElement) {
        const elementRect = restrictingElement.getBoundingClientRect();
        const rect = {
            top: elementRect.top,
            left: elementRect.left,
            height: elementRect.height,
            width: elementRect.width,
        };
        const data = HtmlSubSelectionHelper.getDataForElement(subselectionElement);
        if (data && data.outlineRestrictionOptions) {
            const { margin, padding } = data.outlineRestrictionOptions;
            let x = 0, y = 0, height = 0, width = 0;
            if (margin) {
                const { top, left, right, bottom } = margin;
                x += left;
                y += top;
                height -= (bottom + top);
                width -= (left + right);
            }
            if (padding) {
                const { top, left, right, bottom } = padding;
                x -= left;
                y -= top;
                height += (bottom + top);
                width += (left + right);
            }
            rect.left += x;
            rect.top += y;
            rect.height += height;
            rect.width += width;
        }
        return rect;
    }
    getRectangleSubSelectionOutline(element) {
        const domRect = element.getBoundingClientRect();
        const { x, y, width, height } = domRect;
        const outline = {
            height,
            width,
            x,
            y,
            type: 1 /* SubSelectionOutlineType.Rectangle */,
        };
        if (element.hasAttribute(exports.SubSelectableDirectEdit)) {
            outline.cVDirectEdit = JSON.parse(element.getAttribute(exports.SubSelectableDirectEdit));
        }
        return outline;
    }
    updateRegionOutline(regionOutline, suppressRender = false) {
        this.updateRegionOutlines([regionOutline], suppressRender);
    }
    updateRegionOutlines(regionOutlines, suppressRender = false) {
        for (const regionOutline of regionOutlines) {
            this.subSelectionRegionOutlines[regionOutline.id] = regionOutline;
        }
        if (!suppressRender) {
            this.renderOutlines();
        }
    }
    getElementsFromSubSelections(subSelections) {
        if (!subSelections) {
            return [];
        }
        const elements = [];
        // Update the sub-selection status on the elements
        const subSelectables = this.getSubSelectableElements();
        const isElementSubSelected = this.isElementSubSelected;
        const selectionIdCallbackFn = this.selectionIdCallback;
        d3.selectAll(subSelectables).each(function () {
            let isSubSelected = false;
            // eslint-disable-next-line
            const element = this;
            isSubSelected = isElementSubSelected(element, subSelections, selectionIdCallbackFn);
            if (isSubSelected) {
                elements.push(element);
            }
        });
        return elements;
    }
    // Updates the subselected attribute status on the elements associated with the VisualSubSelection
    setSubSelectedStateDOM(subSelections) {
        if (!subSelections) {
            return;
        }
        // Update the sub-selection status on the elements
        const subSelectables = this.getSubSelectableElements();
        const isElementSubSelected = this.isElementSubSelected;
        const selectionIdCallbackFn = this.selectionIdCallback;
        d3.selectAll(subSelectables).attr(exports.SubSelectableSubSelectedAttribute, function () {
            let isSubSelected = false;
            // eslint-disable-next-line
            const element = this;
            isSubSelected = isElementSubSelected(element, subSelections, selectionIdCallbackFn);
            if (isSubSelected) {
                return true;
            }
            return null;
        });
    }
    isElementSubSelected(element, subSelections, selectionIdCallbackFn) {
        if (!subSelections) {
            return false;
        }
        const selectionObjectName = d3.select(element).attr(exports.SubSelectableObjectNameAttribute);
        const selectionAltObjectName = d3.select(element).attr(exports.SubSelectableAltObjectNameAttribute);
        const isSubSelected = subSelections.some(subSelection => {
            var _a;
            return (_a = subSelection.customVisualObjects) === null || _a === void 0 ? void 0 : _a.some(customVisualObject => {
                let selectorMatches = true;
                if (selectionIdCallbackFn && customVisualObject.selectionId) {
                    const otherSelectionId = selectionIdCallbackFn(element);
                    if (!(0, helperFunctions_1.equalsSelectionId)(customVisualObject.selectionId, otherSelectionId)) {
                        selectorMatches = false;
                    }
                }
                return (customVisualObject.objectName === selectionObjectName || customVisualObject.objectName === selectionAltObjectName) && selectorMatches;
            });
        });
        return isSubSelected;
    }
    /**
     * @returns visualSubSelections that matched a custom outline
     */
    updateCustomOutlinesFromSubSelections(subSelections, visibility = 2 /* SubSelectionOutlineVisibility.Active */) {
        var _a;
        const visualSubSelectionsWithCustomOutlines = [];
        if (this.customOutlineCallback && !(0, helperFunctions_1.isArrayEmpty)(subSelections)) {
            for (const subSelection of subSelections) {
                const customOutlines = this.customOutlineCallback(subSelection);
                if (customOutlines && customOutlines.length > 0) {
                    for (const outline of customOutlines) {
                        const currentOutlineVisibility = (_a = this.subSelectionRegionOutlines[outline.id]) === null || _a === void 0 ? void 0 : _a.visibility;
                        // If the custom outline is recorded & already active, don't set it to hover, reaching 2nd clause implies visibility === SubSelectionOutlineVisibility.Hover
                        if (visibility !== 1 /* SubSelectionOutlineVisibility.Hover */ || currentOutlineVisibility !== 2 /* SubSelectionOutlineVisibility.Active */) {
                            this.setOutline(outline, visibility);
                        }
                    }
                    visualSubSelectionsWithCustomOutlines.push(subSelection);
                }
            }
        }
        return visualSubSelectionsWithCustomOutlines;
    }
    updateOutlinesFromSubSelectionElements(elementsToUpdate, visibility = 2 /* SubSelectionOutlineVisibility.Active */) {
        if (!(0, helperFunctions_1.isArrayEmpty)(elementsToUpdate)) {
            this.updateElementOutlines(elementsToUpdate, visibility, true /* suppressRender */);
        }
    }
    updateOutlinesFromSubSelections(subSelections, clearExistingOutlines, suppressRender) {
        if (clearExistingOutlines) {
            this.hideAllOutlines(true);
        }
        this.subSelections = subSelections;
        let subSelectionsNoCustomOutlines = subSelections ? [...subSelections] : [];
        // Set subselected state for both custom and regular flows together
        this.setSubSelectedStateDOM(subSelections);
        // If visualSubSelection has custom outlines, omit default behavior
        const visualSubSelectionsWithCustomOutlines = this.updateCustomOutlinesFromSubSelections(subSelections);
        if ((visualSubSelectionsWithCustomOutlines === null || visualSubSelectionsWithCustomOutlines === void 0 ? void 0 : visualSubSelectionsWithCustomOutlines.length) > 0) {
            subSelectionsNoCustomOutlines = subSelectionsNoCustomOutlines.filter((visualSubSelection) => !visualSubSelectionsWithCustomOutlines.find((vs) => (0, helperFunctions_1.isEqual)(visualSubSelection, vs)));
        }
        const elements = this.getElementsFromSubSelections(subSelectionsNoCustomOutlines);
        const elementsToShow = elements.filter((e) => d3.select(e).attr(exports.SubSelectableHideOutlineAttribute) !== "true");
        this.updateOutlinesFromSubSelectionElements(elementsToShow);
        if (!suppressRender) {
            this.renderOutlines();
        }
    }
    refreshOutlines() {
        this.updateOutlinesFromSubSelections(this.subSelections, true /*clearExistingOutlines*/, false /*suppressRender*/);
    }
    setOutline(outline, visibility) {
        const helperOutline = Object.assign(Object.assign({}, outline), { visibility, id: outline.id });
        this.subSelectionRegionOutlines[outline.id] = helperOutline;
    }
    static setDataForElement(el, data) {
        el.setAttribute(SubSelectionData, JSON.stringify(data));
    }
    static getDataForElement(el) {
        return el.hasAttribute(SubSelectionData) ? JSON.parse(el.getAttribute(SubSelectionData)) : null;
    }
    hideAllOutlines(suppressRender = false) {
        const allOutlines = this.subSelectionRegionOutlines;
        const updatedOutlines = [];
        for (const outlineId in allOutlines) {
            const outline = allOutlines[outlineId];
            updatedOutlines.push(Object.assign(Object.assign({}, outline), { visibility: 0 /* SubSelectionOutlineVisibility.None */ }));
        }
        this.updateRegionOutlines(updatedOutlines, suppressRender);
    }
    getRegionOutline(id) {
        const outlines = this.getRegionOutlines([id]);
        return outlines[0];
    }
    getRegionOutlines(ids) {
        return ids.map(id => this.subSelectionRegionOutlines[id]);
    }
    getAllOutlines() {
        return Object.assign({}, this.subSelectionRegionOutlines);
    }
    renderOutlines() {
        const regionOutlines = [];
        if (this.subSelectionRegionOutlines) {
            for (const key in this.subSelectionRegionOutlines) {
                regionOutlines.push(this.subSelectionRegionOutlines[key]);
            }
        }
        this.subSelectionService.updateRegionOutlines(regionOutlines);
    }
    getElementRegionOutlineId(selection) {
        const outlineId = selection.attr(exports.SubSelectableObjectNameAttribute);
        let key = "";
        if (this.selectionIdCallback) {
            const selectionId = this.selectionIdCallback(selection.node());
            if (selectionId === null || selectionId === void 0 ? void 0 : selectionId.getSelector()) {
                key = selectionId.getKey();
            }
        }
        if (key !== "") {
            return `${outlineId}___${key}`;
        }
        return outlineId;
    }
    getAllSubSelectables(filterType) {
        const subSelectables = this.getSubSelectableElements();
        const uniquenessCallback = ((a, b) => a.getAttribute(exports.SubSelectableObjectNameAttribute) === b.getAttribute(exports.SubSelectableObjectNameAttribute)
            && (!this.selectionIdCallback
                || (0, helperFunctions_1.equalsSelectionId)(this.selectionIdCallback(a), this.selectionIdCallback(b))));
        const subSelectableElements = (0, helperFunctions_1.getUniques)(subSelectables, uniquenessCallback);
        let filteredTypeSubSelectableElements = subSelectableElements;
        if (filterType) {
            filteredTypeSubSelectableElements = subSelectableElements.filter((subSelectableElement) => {
                const type = this.getSubSelectionTypeFromElement(subSelectableElement);
                return Number(type) === filterType;
            });
        }
        const selectionOrigins = filteredTypeSubSelectableElements.map(element => {
            const boundingBox = element.getBoundingClientRect();
            return {
                x: boundingBox.x + boundingBox.width / 2,
                y: boundingBox.y + boundingBox.height / 2,
            };
        });
        const compareByY = (index1, index2) => {
            return selectionOrigins[index1].y - selectionOrigins[index2].y;
        };
        const YorderedIndices = Array.from(Array(selectionOrigins.length).keys()).sort(compareByY);
        // Take all of the subselectableElements and then create visual subselections and convert into visualSubSelection[]
        const visualSubSelections = YorderedIndices.map(index => (this.createSubSelectionFromElement(filteredTypeSubSelectableElements[index], false /*showUI*/, undefined /*event*/, selectionOrigins[index])));
        return visualSubSelections;
    }
    createVisualSubSelectionForSingleObject(createVisualSubSelectionArgs) {
        const { objectName, subSelectionType, displayName, showUI, selectionId, selectionOrigin, focusOrder, metadata } = createVisualSubSelectionArgs;
        const useOfssetInSelection = selectionOrigin && subSelectionType in [1 /* SubSelectionStylesType.Text */, 2 /* SubSelectionStylesType.NumericText */];
        const origin = useOfssetInSelection ? Object.assign(Object.assign({}, selectionOrigin), { offset: { x: 0, y: (selectionOrigin === null || selectionOrigin === void 0 ? void 0 : selectionOrigin.y) * -1 } }) : selectionOrigin;
        const visualSubSelection = Object.assign(Object.assign({ customVisualObjects: [{ objectName, selectionId: selectionId !== null && selectionId !== void 0 ? selectionId : undefined }], showUI,
            displayName,
            subSelectionType, selectionOrigin: origin }, metadata ? { metadata } : {}), focusOrder ? { focusOrder } : {});
        return visualSubSelection;
    }
    createSubSelectionFromElement(element, showUI, event, prevSelectionOrigin) {
        // Need to get display name from jqdata, get selector from datum
        const objectName = element.getAttribute(exports.SubSelectableObjectNameAttribute);
        let selectionId;
        if (this.selectionIdCallback) {
            selectionId = this.selectionIdCallback(element);
        }
        const subSelectionType = this.getSubSelectionTypeFromElement(element);
        const displayName = this.getDisplayNameFromElement(element);
        let selectionOrigin = prevSelectionOrigin;
        if (event) {
            selectionOrigin = {
                x: event.clientX,
                y: event.clientY,
            };
        }
        const visualSubSelection = this.createVisualSubSelectionForSingleObject({
            objectName,
            subSelectionType,
            displayName,
            showUI,
            selectionId,
            selectionOrigin,
        });
        return visualSubSelection;
    }
    getDisplayNameFromElement(element) {
        var _a;
        return (_a = element.getAttribute(exports.SubSelectableDisplayNameAttribute)) !== null && _a !== void 0 ? _a : '';
    }
    getSubSelectionTypeFromElement(element) {
        const type = element.getAttribute(exports.SubSelectableTypeAttribute);
        if (!type) {
            return undefined;
        }
        return Number(type);
    }
    getSubSelectableElements() {
        const hostElement = this.hostElement;
        return this.host
            .selectAll(exports.HtmlSubSelectableSelector)
            .filter(function () {
            // eslint-disable-next-line
            const element = this;
            return helperOwnsElement(hostElement, element);
        }).nodes();
    }
}
exports.HtmlSubSelectionHelper = HtmlSubSelectionHelper;
//# sourceMappingURL=HtmlSubSelectionHelper.js.map